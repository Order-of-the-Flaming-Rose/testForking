- движок выполняет задачи начиная с самой старой 
- очередь задач в движке js называеться очередью макрозадач
- такие макрозадчи можно нарезать по возможности на микрозадачи для того чтобы 
можно было выполнять менее трудоемкие задачи в перерывах 


class properties ===============
флаги и дескрипторы свойств 
помимо value имеет также и другие характеристики 

vritable - можно ли читать это свойство 
enumerable - можно ли проходить цыклом по этому свойству 
configurable - можно менять, удалать свойство 

они скрыты но их можно регулировать 

Object.defineProperty(obj, propertyName, descriptor)


function's methods 

call 
метод функции 
можно просто вызвать функцыю 

func()
func.call() 
будет одинаковый результат 

но в саll можно передать контекст 
это имеет сысл если внутри функции есть обращение к контексту 

потому на практике это юзаеться с классами с методами обьектов чаще чем с функциями 

или же можно взять метод массива и передать в него обьект 
[].map.call({object});

const nevfuncwithalienmethod = func.bind({}, ...args)
можно пересоздать функцыю но с чужим контекстом 


promise 
- это конструктор который принимает колбек функцыю которая в свои параметры тоже принимает два колбека (resolve,reject)

метод then также принимает 2 колбека 
- первый если успех
- второй - альтернатива catch, если ошибка 




промисы ============

есть создание обьектов с помощью конструктора 
промис создаеться также через нью 
тоесть ето функция которая вовращает класс 

способ взаимодействия с входными данными

promise можно использовать внутри асинхронной функции которая принимает какой либо аргумент 
и такую функцыю можно импортировать и использовать в других модулях 
в промисе можно обращаться в переменным которые находяться в области видимости промиса 


=========
js 
= однопоточный язык програмирования 
состоит из 
1 - стэк 
2 - хип 
структура стека js - последним пришел первым ушел 

имент луп 
1) колстек 
2) очередь 


при вызове функции 
1 функцыя кладеться в стэк вместе из ее контекстом выполнения 
2 внутренние функции кладуться на верх стека 
    они раньше удаляються из стэка 
        тут как раз и работает принцып - последним пришел первым ушел 
         

в стеке накопление происходит когда есть рекурсия или апеляцыя к функцыям внутри текущей макрозадачи - функции 

макс глубина стэка 100 000 операцый 

есть вебапи котороео может принять в себя задчу и отправить ее в очередь 


//justify-content: работает для flex 
// justify-items: работать для пкшв



пути к файлам 

file.js - текущая папка 
./file.js - текущая папка 

/file.js - корневая папка
../file.js - на уровень выше 

=======

метатеги 
title
style
link
script

meta : кодировка
     ключевые слова 
     краткое описание 
     автор 
     автоперезагрузка
     вьюпорт : значение ширины и значение масштаба 


/////
рест и спред операторы 

рест оператор в момент вызова функции берет неопределенное количество 
параметров и кладет в масив - в переменную рест 

рест оператор ставиться вконце 

оператор расширения 

позволяет раскрывать массивы и другие колекции элементов 
для слияние масивов, копирования обьектов и передачи масива в виде переменных вне массива 

копирование обьекта let newObj = { ...obj };


///////
логические операторы 
!=, ||, &&

true || x = 5 

x === undefined - вычесление не дойдет до присвоения 


&& 
если все истинно вернет последний 
{isLoading && <Loader>}


?? принимает отрицательные значения если они извечтны и определены : false, 0

//==
прототипное наследование 
_proto_ - это сеттер для свойства prototype 

он не помещает в обьект свойства предка 
но в потомке можно обращаться к этим свойствам 
т/к они храняться в свойстве [[prototype]]

2 условия прототипного наследования 
- незьзя наследоваться по кругу
- нельзя наследоваться больше чем от одного предка 

================
можно сетить свойстава в непосредственный обект не смотря на наличие в прототипе такого же свойства 

for..in проходит и по унаследованым свойствам 

obj.hasOwnProperty(key): возвращает true только на личние свойства а не унаследованые 

используя prototype = можно добавить возможность вызова нанного свойства из прототипа
можно добавить в прототип свойство или метод

============ё
метатеги 
favicon - иконка для вкладки 

description,keywords,author - метатеги для поисковых систем

og: name img title - теги для отображения в соцыальных сетях ссылок на сайт 

viewport - 
    есть значенія 
    шіріна 
    масштаб 


// колекции 
Map();
    єто колекция состоящія із пар ключ : значение 
    - отлічіе в том что в качестве ключа можно іспользовать обьекти 
    есть свойства size, set, has, values

    мап в консттруктор пріімает массів іх массівов Object.entries(obj);

    кстаті есть Object.fromEntries создает обьект із пар [key:value]


Set()

клекція унікальних значеній 
ключи в сет номера 
- імеет свойства size,values,entries,add,delete

weakmap,weakset - не хранит ссилку на адрес в памяти, а хранит переменную с силкой на ісходную переменную 

//=========================

діструктурірующіе прісваіваніе 

самые частоиспользуемые структуры данных 
obj arr 
const {var1,var2,var3} = obj

//===========
strings 

перезаписать символ в строке нельзя - можно перезаписать всю строку 

indexOf() вернет либо индекс либо -1 

поиск подстроки includes 

сравнение строк === сравнение номеров в кодировке 

=============
arr 
array.slise(start,end) - возвращает обрезаную копию массива 

push - добавляет в конец 
pop - удаляет с конца 

sfift - извлекает из начала елемент 
unshift - добавляет в начало елемент

splise - 
может удалять и добавлять в массив елементы 

не возвращает нов массив а изменяет старый

принимает 3 аргумента 

старт 
сколько елементов удалить 
нов елементы 

flex patterns 
flex-basis: 100%; элементы занимаю всю ширину контейера 


/'/когда промис выполнен его обработчики отправляються в очередь микрозпдач






каррирование позволяет частично вызывать функцыю частично 























